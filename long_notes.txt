Things to look at:
- IPFS content addressing
- libp2p
- bittorrent protocol
- TOR (doesn't TOR use a DNS for hidden services basically?)

####################################################################################################
DEATH TO TCP/IP .. ::hmm::
https://www.theregister.co.uk/2014/09/05/named_data_networking_consortium_launches_to_replace_tcp_ip/

- NDN (named data networking)
- Current Internet stack looks something along the lines of
  
  Application
  -----------
  Transport
  ---------
  IP
  --
  Data Link
  ---------
  Physical
  -----------

- proposed NDN stack
 
  Application
  -----------
  Security
  --------
  Content
  --
  Strategy
  --------
  Data/Network/Transport?
  ---------
  Physical
  -----------

####################################################################################################
SCION Five Years Later
https://arxiv.org/pdf/1508.01651.pdf
Paper is in papers/ directory should online pdf become unavailable

- point to point communication that remains _high available_ despite adversary presence
- transparency and control over forwarding paths
  - containing packet path in header?
- transparency and control over trust roots (CAs)
  - lack of transparency to users
  - end host path selection results in simpler forwarding plane and more efficient routers
- introduction of state into packet headers
  - reasoning behind this is that memory lookups (routing table lookups) are very slow compared
    to just doing computations (like AES?)
  - packet needs to be protected cryptographically
  - can protect against router state exhaustion attacks it seems
- PKI (public key infrastructure), what we rely on so much right now, is based off trusting
  a small number of people/organisations
  - trust architecture which supports a global trust root between distrusting entities
- make new stuff deployable

- SCION tries to find the bare minimum that a global, interoperable communication system
  should have. Things like efficient distribution can be added on at higher levels.
  Sticks with IP's best effort motto
  Isolates security to only things that affect the network - malicious components

- ISD -> isolated domain
         basically a section of the Internet controlled by one ISP
- AS -> autonomous system
- ISD Core -> AS that administers the ISD
- TRC -> Trust Root Configuration, policy which governs the ISD
- PCB -> path construction beacon
      -> appears to be a packet which, as it passes through nodes,
         gets links appended. Just keeps track of its path down from Core to leaf nodes
        -> Nothing seems to stop higher up nodes from distributing false information or
           simply nothing at all
           I think to resolve that, the hope is that since there are so many routes,
           each node underneath a malicious node will have multiple paths to go through in
           order to avoid bad paths
           
           To really stop a lower AS from communicating with a Core, there needs to be a lot
           of collusion between higher level ASes
- PCFS -> path carried forwarding state

maybe I'm hitting the  m e a t  of the paper now

- inter and intra ISD routing
- packets contain AS-level path information so we dont need border routers to maintain
  inter-domain routing tables
  .
  .
  ....... ?? i dont get this one
- through inter-domain PCB transmissions, each Core AS learns paths to all other Core ASes??
- PCFS is different to source routing as the source node doesn't need to search a graph
  .
  .
  . maybe i'll understand later...
- Control plane
  beacon servers -> discover path information
                    something something something Border Gateway Protocol?

                    works to create disjoint paths for max availability
                    
                    page 9 of the paper has a good diagram which I wont convert to ascii for
                    the sake of my sanity
                    
                    Inter-ISD beaconing is the same as intra-ISD beaconing except the packets only
                    travel between Core ASes
                    THE PAPER HIGHLIGHTS THAT THIS ISN'T SCALABLE SIMILAR TO BGP
  path servers -> disseminate path information
                  store mappings from AS identifiers to sets of announced path segments
                  
                  path selection from AS to AS appears to consist of 3 sections:
                    Up-segment    -> path from AS to an ISD Core
                    Core-segment  -> path between ISD Cores
                    Down-segment  -> path between ISD Core to AS

                  This allows a path between 2 ASes to consist of an up and down segment of any size
                  if there's a link or shortcut (doesn't have to reach a Core AS).
  certificate servers -> assist validating received information
                         keep cached copies of TRC files from ISD Core and copies of other ASes
                         certs and manage certs and keys for intra-AS communication
- with the path in the packet, border routers don't need to contain extra information about
  routing tables as the set path is specified. Also allows responders to either pick their own
  path or to simply invert the given path.
- PCBs are sent based on a local timer - 10 or 15 seconds
    Sounds like a lot of extra traffic on the network to me...
- paths are static... which isn't amazing
  but paths are distributed kind of frequently meaning that there'll be many choices if one link fails
  but one link failing in a path means that path can't be used..
  but there *should* be many paths to pick from

The  m e a t  above is the control layer. It just distributes information about paths and the network.
The data plane is where PCFS comes in.

- A SCION packet contains at least a path
- This way, we can actually allow hosts that are using different protocols (IPv4, IPv6) to communicate
  with each other

- Current internet trust model follows `monopoly` and `oligarchy`
  monopoly - one overlord to rule them all
  oligarchy - a few equally valid overlords to rule them all
- SCION attempts to mitigate this by isolating authorities to individuals ISDs. If something gets
  compromised within an ISD, oh no, but at least all other ISDs aren't compromised

- path validation, anonymity, privacy and DDos protection
  - on the note with anonymity/privacy, the path selection thing kind of appears similar to TOR

The rest of the paper goes on to describe possible security threats, some case studies and examples
and some other architectures/protocols.

####################################################################################################

SERVAL: service-centric networking

- first thing the paper does is say today's network stack doesn't suit mobile and multi-homed devices. But hey it still suits things that don't need to change quite well.
- hosts have addresses that are dependent on the network topology
  - we _want_ a way to address a service ?_or interface_? with a topology independent address
- current workarounds are load balancers and manual changes to DNS configs etc.
- proposes a SERVICE ACCESS LAYER (SAL) which sits on top of an unchanged network layer
- splitting of data and control plane
- Mobile IP seems fun

Issues with today's network stack
- hosts cannot spread a connection over multiple interfaces or paths
- overloading of meaning on addresses
  - to identify interfaces (IP)
  - demultiplex packets (port)
  - identify sockets (source:destination tuples)
  - differentiate service endpoints (IP:port)
  - identify application protocols (ports... kinda)
- Services require external knowledge or assumptions to use. For example, HTTP runs on port 80. It's kind of known by everyone and assumed but nothing stops someone from running a HTTP server on 443 if they really want.
- caching makes failover and updating slow

We see the word `flow` a lot in this paper. I'm taking it to be the exchange of data on a socket/port. Eg. a TCP flow would be along the lines of syn, synack, ack, data exchange... etc.

- Serval provides a service-aware network stack
  - apps communicate on _service names_ rather than addresses and ports
    - service name -> identify a service (serviceID)
                   -> corresponds to a group of 1+ possibly changing processes offering the same service
                   
                          /--> < Service_a >
                         /
  |------|              /
  |client| ---> ServiceID ---> < Service_a >
  |------|               \
                          \--> < Service_a >
                   
                   -> ServiceID abstraction hides how the network to the service is structured. Kind of acts as an implicit load balancer from what I can tell


    - flow identifier -> identify the flow associated with a socket
    - network addresses -> identify interfaces on a host
- late binding of services to hosts
- communication over active sockets using _service names_
  A host becomes a `singleton group` .... instead of being just a single host, it can be part of a group of hosts that all perform the same service?
- IP anycast
- TCP/IP relies on
  <source IP, source port, destination IP, destination port, protocol>
  to demultiplex packets to sockets. This kinda prevents any mobility as if one thing changes, the socket is disrupted.
- a service instance listens on a serviceID
- example packet with Serval stuff in it
  
  (network layer)     | src addr | dest addr | ...
                      | source flowID | dest flowID | trans prot | flags |
                      | seq # | ack # | nonce | serviceID |
  (transport layer)   | app prot | .... 

- by ignoring the five-tuple for flow identification, Serval supports both IPv4 and IPv6 and whatever else there is
- applications interact with a SAL port much the same way they do with TCP:IP ports
  s = socket(PF_SERVAL)
  bind(s, serviceID)
  sendDatagram(s, serviceID, data)
  
  note how now applications aren't talking directly via TCP/IP sockets so if anything in the 5-tuple changes, everything's still fine... from the application's point of view
- figure 5 on page 7 of the paper indicates an example how establishing a Serval connection based on serviceID works
  The paper says that the initial establishment may have a bit of an extra delay but data packets are unaffected

- this all sounds very much like a load balancer..? 
- IP : finds hosts by ip addresses
  TCP: finds applications via ports
  
  Currently, the stack looks like IP:PORT
  but if we depend on another abstraction, it could look like
  IP:FLOW , FLOW:PORT
  meaning that as long as FLOW stays the same, 2 machines can change
  ip addresses and ports and they'd stil lbe able to talk.

  The downside with this obviously is that attackers, if able to grab
  the FLOW, they can impersonate either end. Hence security is kinda bad
  as is.
  .......
  Is this what Serval is kinda doing?

